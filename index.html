<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>IT 202 Project 2</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
    
    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

    <style>
    canvas {
      height: 100vh;
      width: 100vw;
      position: absolute;
      background-color: "white";
    }
    body {
      margin: 0;
      padding: 0;
      background-color: "white";
    }
    </style>

  </head>

  <body>

    <canvas id="gameCanvas"></canvas>

    <script>

      // setup the object that defines the state of the game
      let gameObj = {
        gameStarted: false,
        gamePaused: false,
        gamWon: false,
        gameOver: false,
        level: 1
      };
     

      // define the key codes of the keyboard keys
      let downArrow = 40;
      let upArrow = 38;
      let wKey = 87;
      let sKey = 83;

      // define the requestAnimationFrame
      let requestAnimationFrame = window.requestAnimationFrame ||
                                  window.mozRequestAnimationFrame ||
                                  window.webkitRequestAnimationFrame ||
                                  window.msRequestAnimationFrame;

      // set the canvas and context objects
      let canvas = document.querySelector("canvas");
      // canvas.style.backgroundColor = "silver";
      let context = canvas.getContext("2d");

      
      // function to draw the game data
      let drawGameData = () => {
        context.font = "bold 20px Helvetica, Arial, sans-serif";
        context.fillStyle = "white";
        context.fillText(" |  Score : " + player.score, 40, 40);
        context.fillText(" |  Lives : " + player.life, 40, 70);
        context.fillText(" |  Level : " + gameObj.level, 40, 100);
      }

      // set the player's properties
      let playerX = (canvas.width / 2) + 100;
      let playerY = (canvas.height / 2);
      let playerRadius = 110;
      let playerRing = 8;
      let playerSpeed = 20;
      let playerColor = "white";
      let playerfill = "transparent";

      // set player's life property
      let playerLife = 5;

      // set the player's score
      let playerScore = 0;

      // define the player's image
      let playerImg = new Image();
      playerImg.src = "gameAssets/ship2.png";

      // assign the initial properties of the player
      let player = {
        x: playerX, 
        y: playerY,
        radius: playerRadius,
        ring: playerRing,
        strokeColor: playerColor,
        fillColor: playerfill,
        speed: playerSpeed,
        life: playerLife,
        score: playerScore,
        img: playerImg
      };
 
      // add background image
      const backgroundImage = new Image();
      backgroundImage.src = 'gameAssets/bg.jpg';
      backgroundImage.position = { x: 0, y: 0};

      // add the stars slide
      const stars = new Image();
      stars.src = 'gameAssets/stars.png';
      stars.position = { x: 0, y: 0};

      // add the second slide of stars
      const stars2 = new Image();
      stars2.src = 'gameAssets/stars.png';
      stars2.position = { x: (canvas.width + 1550), y: 0};

      // function to check if two objects objects are colliding
      let areColliding = (obj1, obj2) => {
        let dx = obj1.x - obj2.x;
        let dy = obj1.y - obj2.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < obj1.radius + obj2.radius) {
          return true;
        }
        return false;
      }

      // define the enemy / harm objects
      let numEnemies = 2;
      let enemyRadius = 40;
      let enemyColor = "red";
      let enemySpeed = 10;
      let enemyImg = new Image();
      enemyImg.src = "gameAssets/meteor.svg";
      
      // define the collection of enemy objects
      let enemies = [];

      // add elements to the collection of ememy objects
      for (let i = 0; i < numEnemies; i++) {
        // let x = (canvas.width) + 1635;
        let x = (canvas.width) + 1500;
        let y = enemyRadius + (Math.random() * (canvas.height - (2 * enemyRadius)));
        
        // let direction = Math.random() * 2.0 * Math.PI;
        enemies.push({
                      x:x, 
                      y:y, 
                      radius:enemyRadius, 
                      speed:enemySpeed, 
                      colour:enemyColor,
                      img:enemyImg
                    });
      }

      // function to check if the enemy objects are colliding
      // if colliding, then re-draw then in a new position
      let checkEnemyCollision = () => {
        enemies.forEach( (objA) => {
          enemies.forEach( (objB) => {
            
            // check if we are not comparing the same circle
            if (objA != objB) {
            
              // check if the circles are colliding
              if (areColliding(objA, objB)) {
            
                // reposition one of the circles in a random y coordinate
                objA.y = objA.radius + (Math.random() * (canvas.height - (2 * objA.radius)));
              }
            }
          });
        });
      }

      // check for collision between the player and the enemy / harm objects
      let playerEnemyCollision = () => {
        
        // iterate over each enemy element
        enemies.forEach( (enemy) => {
          
          // check for collision
          if (areColliding(player, enemy)) {
            player.life -= 1; // decrement player life
            enemy.x = (canvas.width);
            enemy.y = enemy.radius + (Math.random() * (canvas.height - (2 * enemy.radius)));
          }
        });   
      }

      // function to draw the ememy / harm objects
      let drawEnemies = () => {
        enemies.forEach( (enemy) => {
          // draw the ring
          context.beginPath();
          context.arc(enemy.x, enemy.y, enemy.radius, 0, 2*Math.PI);
          context.strokeStyle = enemy.colour;
          context.fillStyle = "transparent";
          context.lineWidth = 8;
          context.shadowColor = 'yellow';
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowBlur = 15;
          context.closePath();
          context.fill();
          context.stroke();
          
          // draw the enemy's image
          context.drawImage(enemy.img, (enemy.x - 42), (enemy.y - 95), 200, 200);
          
          // change the posiion of the enemy object
          enemy.x -= enemy.speed;
        });
        
        // check if the enemy objects are colliding
        checkEnemyCollision();
      }

      document.addEventListener("DOMContentLoaded", (event) => {

        // function to draw the player
        let drawPlayer = () => {
          
          // draw the player's image
          context.drawImage(player.img, (player.x - 90), (player.y - 110), 180, 220);

          // draw the ring around the player
          context.beginPath();
          context.arc(player.x, player.y, player.radius, 0, 2*Math.PI);
          context.strokeStyle = player.strokeColor;
          context.fillStyle = player.fillColor;
          context.lineWidth = player.ring;
          context.shadowColor = 'white';
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowBlur = 15;
          context.closePath();
          context.fill();
          context.stroke();
        }
        
        // function to check if the player is going off bounds
        let playerEdgeCheck = (player) => {
          if ((player.y - player.radius) < 0) {
            player.y = player.radius;
          } else if ((player.y + player.radius) > canvas.height) {
            player.y = canvas.height - player.radius;
          }
        }

        // function to check if the enemy object is going off bounds
        let enemyEdgeCheck = (enemies) => {
          enemies.forEach( (enemy) => {
            if ((enemy.x - enemy.radius) < 0) {
              enemy.x = (canvas.width);
              enemy.y = enemy.radius + (Math.random() * (canvas.height - (2 * enemy.radius)));
            }
          });
        }

        // get the device pixel ratio
        dpi = window.devicePixelRatio;

        // fix the device pixel ratio
        let fix_dpi = () => {
          
          // create a style object that returns width and height
          let style = {
            height() {
              return +getComputedStyle(canvas).getPropertyValue('height').slice(0,-2);
            },
            width() {
              return +getComputedStyle(canvas).getPropertyValue('width').slice(0,-2);
            }
          }
          
          // set the correct attributes for a crystal clear image!
          canvas.setAttribute('width', style.width() * dpi);
          canvas.setAttribute('height', style.height() * dpi);
        }

        const draw = () => {
          // fix the device pixel ratio
          fix_dpi();
          
          // clear previous scene
          context.clearRect(0, 0, canvas.width, canvas.height);

          // draw the background
          context.drawImage(backgroundImage, backgroundImage.position.x, backgroundImage.position.y, canvas.width, canvas.height);


          // set the player ring color to red to symbolize danger
          if (player.life <= 1) {
            player.strokeColor = "red";
          } 

          // draw the game data
          drawGameData();

          // draw the player
          drawPlayer();

          // draw the enemies
          drawEnemies();

          // check for collision between player and enemy / harm objects
          playerEnemyCollision();

          // check if player hits the edge
          playerEdgeCheck(player);

          enemyEdgeCheck(enemies);

          // invoke request animation frame
          requestAnimationFrame(draw);
        }
        draw();

      });

      // add an event listner for keydown of the up arrow key
      document.addEventListener("keydown", (event) => {
        
        switch(event.keyCode) {
          // up arrow
          case (upArrow): {
            player.y -= player.speed;
            break;
          }
          // down arrow
          case (downArrow): {
            player.y += player.speed;
            break;
          }
           // w key (up)
          case (wKey): {
            player.y -= player.speed;
            break;
          }
          // s key (down)
          case (sKey): {
            player.y += player.speed;
            break;
          }
          // default case - unwanted key is pressed
          default: {
            console.log("case fell through");
          }
        }

      });

    </script>
  </body>
</html>